rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {

    // ---- Helpers -----------------------------------------------------------
    function isSignedIn() { return request.auth != null; }
    // Return the caller's role string for the given orgId, or null when absent.
    function role(orgId) {
      return request.auth != null ? request.auth.token.roles[orgId] : null;
    }
    // For v12 we treat "Manager" as equivalent to admin for UI;
    // keep backward-compatible aliases accepted in rules.
    function isManager(orgId) {
      let r = role(orgId);
      return r == 'manager' || r == 'admin' || r == 'org_admin' || r == 'org_owner';
    }
    function isMember(orgId) {
      let r = role(orgId);
      return isManager(orgId) || r == 'member' || r == 'org_member';
    }

    // ---- Users -------------------------------------------------------------
    match /users/{uid} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && uid == request.auth.uid;
    }

    // ---- Join Tokens (top-level) ------------------------------------------
    match /join_tokens/{tokenId} {
      // Anyone signed-in can read to validate a token client-side.
      allow read: if isSignedIn();
      // Only managers can create/delete for their org.
      allow create: if isSignedIn() && isManager(request.resource.data.orgId);
      allow delete: if isSignedIn() && isManager(resource.data.orgId);
    }

    // ---- Organizations namespace ------------------------------------------
    match /organizations/{orgId} {
      // Members (incl. managers) can read/list; anyone can create an org doc.
      allow get, list: if isMember(orgId);
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isManager(orgId);

      // Members subcollection
      match /members/{uid} {
        // Member list is visible to members; user can read their own.
        allow read: if isMember(orgId) || (isSignedIn() && uid == request.auth.uid);
        // A user may create their own membership (e.g., joining); manager may also write.
        allow create: if isSignedIn() && uid == request.auth.uid;
        // Managers can update any; user can update own (e.g., profile fields you allow).
        allow update: if isManager(orgId) || (isSignedIn() && uid == request.auth.uid);
        // Only managers can delete membership.
        allow delete: if isManager(orgId);
      }

      // Schedules + shifts
      match /schedules/{sid} {
        // All org members can read schedules
        allow read: if isMember(orgId);
        // Only managers can create/update/delete schedules
        allow create, update, delete: if isManager(orgId);

        match /shifts/{shiftId} {
          // Members can read shifts
          allow read: if isMember(orgId);
          // Managers can CRUD any shift; a user may create/update/delete *their own* shift
          // when request payload binds userId to the caller.
          allow create, update, delete: if isManager(orgId) ||
            (isSignedIn() && request.resource.data.userId == request.auth.uid);
        }
      }

      // Messages + receipts (publish notifications, inbox)
      match /messages/{mid} {
        // Only managers create messages (e.g., publish notices)
        allow create: if isSignedIn() && isManager(orgId);

        // Read logic is target-aware:
        // - "all": anyone signed-in can read (within org scope because path has orgId and listing requires membership)
        // - "members": members of this org can read
        // - "user": recipients array contains the caller uid
        allow read: if isSignedIn() && (
          resource.data.targets == 'all' ||
          (resource.data.targets == 'members' && isMember(orgId)) ||
          (resource.data.targets == 'user' && (request.auth.uid in resource.data.recipients))
        );

        // Per-user receipts subcollection
        match /receipts/{uid} {
          // Recipient writes their own receipt; managers can read for delivery analytics
          allow write: if isSignedIn() && uid == request.auth.uid;
          allow read: if isSignedIn() && (uid == request.auth.uid || isManager(orgId));
        }
      }

      // Org-level receipts collection (v12 tests expect this path)
      match /receipts/{rid} {
        // Caller may create/update their own receipt document when payload binds userId to caller
        allow create, update: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        // Caller can read their own; managers can read all for analytics
        allow read: if isSignedIn() && (resource.data.userId == request.auth.uid || isManager(orgId));
        // Deletions reserved to managers
        allow delete: if isSignedIn() && isManager(orgId);
      }

      // Attendance records (v12 keeps this simple; write-your-own; managers update)
      match /attendance_records/{recordId} {
        allow read: if (isMember(orgId) && resource.data.userId == request.auth.uid) || isManager(orgId);
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update: if isManager(orgId);
      }
    }

    // Server-only ledger (hash chain)
    match /attendance_ledger/{id} {
      allow read, write: if false;
    }
  }
}
