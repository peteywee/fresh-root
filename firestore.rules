// [P1][INTEGRITY][RULES] Firestore security rules for multi-tenant RBAC
// Tags: P1, INTEGRITY, FIRESTORE, RULES, SECURITY, RBAC, TENANT_ISOLATION
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() { return request.auth != null; }
    function uid() { return request.auth.uid; }
    function userOrgId() { return request.auth.token.orgId; }
    function userRoles() { return request.auth.token.roles; }

    // Token-based role checking (new style with custom claims)
    function hasAnyRole(roles) {
      return isSignedIn() && userRoles() != null && userRoles().hasAny(roles);
    }

    // Org membership checking (legacy style with membership docs)
    function isOrgMember(orgId) {
      return exists(/databases/$(database)/documents/memberships/$(uid() + "_" + orgId));
    }

    // Legacy role checking using membership documents
    function hasAnyRoleLegacy(orgId, roles) {
      return isOrgMember(orgId) &&
        get(/databases/$(database)/documents/memberships/$(uid() + "_" + orgId)).data.roles.hasAny(roles);
    }

    // Combined check: token-based (preferred) or legacy membership doc
    function isManager() {
      return hasAnyRole(['org_owner','admin','manager']);
    }

    function sameOrg(resourceOrgId) {
      return isSignedIn() && userOrgId() == resourceOrgId;
    }

    // Users: self only; no enumeration
    match /users/{userId} {
      allow read, create, update: if isSignedIn() && userId == uid();
      allow list: if false;
    }

    // Orgs - read by members, write by org_owner
    match /orgs/{orgId} {
      allow get: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
      allow create: if isSignedIn();
      // Only org_owner (token) or legacy owner/admin can update/delete
  allow update, delete: if isSignedIn() && ((hasAnyRole(['org_owner']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin']));
      allow list: if false;

      // Schedules as subcollection under orgs
      match /schedules/{scheduleId} {
  allow read: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
        allow write: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager','scheduler']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager','scheduler']));
      }

      // Positions as subcollection under orgs
      match /positions/{positionId} {
  allow read: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
        allow write: if isSignedIn() && ((isManager() && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      }

      // Shifts as subcollection under schedules
      match /schedules/{scheduleId}/shifts/{shiftId} {
        // Allow reading (including listing) within org
        allow read: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
        // Allow scheduler+/manager/owner writes
        allow write: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager','scheduler']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager','scheduler']));
        // Allow staff to update their own shift with limited fields only
        allow update: if isSignedIn() && sameOrg(orgId) && resource.data.userId == uid() &&
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['notes','checkInTime','updatedAt']);
      }

      // Join tokens - managers can create/manage
      match /join_tokens/{tokenId} {
        allow read: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
        allow write: if isSignedIn() && ((isManager() && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      }
    }

    // Organizations (alternate path) - alias for orgs
    match /organizations/{orgId} {
      allow get: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
      allow create: if isSignedIn();
  allow update, delete: if isSignedIn() && ((hasAnyRole(['org_owner']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin']));
      allow list: if false;

      // Messages - managers can create, all members can read
      match /messages/{messageId} {
        allow read: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
        allow write: if isSignedIn() && ((isManager() && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      }

      // Receipts - members can create their own receipts only
      match /receipts/{receiptId} {
        allow read: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
        allow create: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId)) && request.resource.data.userId == uid();
        allow update, delete: if isSignedIn() && resource.data.userId == uid();
      }

      // Schedules as subcollection under organizations
      match /schedules/{scheduleId} {
        allow read: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
        allow write: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager','scheduler']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager','scheduler']));
      }

      // Positions as subcollection under organizations
      match /positions/{positionId} {
        allow read: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
        allow write: if isSignedIn() && ((isManager() && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      }
    }

    // Memberships: id = uid_orgId
    // Token-based: managers can create/update
    // Legacy: users can create their own
    match /memberships/{membershipId} {
      allow read: if isSignedIn() && (
        resource.data.uid == uid() ||
        (isManager() && sameOrg(resource.data.orgId)) ||
        hasAnyRoleLegacy(resource.data.orgId, ['owner','admin','manager'])
      );
      allow create: if isSignedIn() && (
        request.resource.data.uid == uid() ||
        (isManager() && sameOrg(request.resource.data.orgId))
      );
      allow update, delete: if isSignedIn() && (
        (isManager() && sameOrg(resource.data.orgId)) ||
        hasAnyRoleLegacy(resource.data.orgId, ['owner','admin','manager'])
      );
      allow list: if false;
    }

    // Org-scoped resources (top-level per org) — block listing by using get instead of read
    match /venues/{orgId}/venues/{venueId} {
      allow get: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
      // Create/Update by manager+, Delete by owner/admin only
      allow create, update: if isSignedIn() && ((isManager() && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      allow delete: if isSignedIn() && ((hasAnyRole(['org_owner','admin']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin']));
      allow list: if false;
    }

    match /zones/{orgId}/zones/{zoneId} {
      allow get: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
      allow write: if isSignedIn() && ((isManager() && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      allow list: if false;
    }

    match /positions/{orgId}/positions/{positionId} {
      allow get: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
      allow write: if isSignedIn() && ((isManager() && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      allow list: if false;
    }

    // Schedules (top-level per org) - manager+ can write, block listing
    match /schedules/{orgId}/schedules/{scheduleId} {
      allow get: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
      // Create/Update by scheduler+, but restrict delete to manager+ (no scheduler)
      allow create, update: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager','scheduler']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager','scheduler']));
      allow delete: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      allow list: if false;
    }

    // Shifts (top-level per org) - block listing; writes by scheduler+; staff can update own limited fields
    match /shifts/{orgId}/shifts/{shiftId} {
      allow get: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
      // Create/Update by scheduler+/manager/owner; delete by manager+ only (no scheduler)
      allow create, update: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager','scheduler']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager','scheduler']));
      allow delete: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      // Staff self-service limited updates
      allow update: if isSignedIn() && sameOrg(orgId) && resource.data.userId == uid() &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['notes','checkInTime','updatedAt']);
      allow list: if false;
    }

    // Attendance (top-level per org) — block listing; writes by scheduler+/manager/owner only
    match /attendance_records/{orgId}/records/{recordId} {
      allow get: if isSignedIn() && (sameOrg(orgId) || isOrgMember(orgId));
      // Only scheduler+/manager/owner can create/update/delete
      allow create, update: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager','scheduler']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager','scheduler']));
      allow delete: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      allow list: if false;
    }

    // Join tokens (non-enumerable) — owner/admin only
    match /join_tokens/{orgId}/join_tokens/{tokenId} {
      // Managers can read token metadata; write restricted to owner/admin
      allow get: if isSignedIn() && ((hasAnyRole(['org_owner','admin','manager']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin','manager']));
      allow create, update, delete: if isSignedIn() && ((hasAnyRole(['org_owner','admin']) && sameOrg(orgId)) || hasAnyRoleLegacy(orgId, ['owner','admin']));
      allow list: if false;
    }

    // ---------------------------------------------------------------------------
    // Network (tenant root) rules – v14.0.0
    // @see docs/bible/Project_Bible_v14.0.0.md Section 5 (Security Rules)
    // @see docs/schema-network.md
    // ---------------------------------------------------------------------------

    // Helper functions for network-level access control
    function isNetworkMember(auth, networkId) {
      // TODO: Check if user has a membership doc under /networks/{networkId}/memberships/{uid}
      // For now, allow all authenticated users (stub)
      return auth != null;
    }

    function isNetworkOwner(auth, networkId) {
      // TODO: Check if auth.uid matches network.ownerUserId
      // For now, stub with false (backend only)
      return false;
    }

    function isNetworkAdmin(auth, networkId) {
      // TODO: Check if user has network_admin or network_owner role in memberships
      // For now, stub with false
      return false;
    }

    function isSuperAdmin(auth) {
      // TODO: Check custom claim for platform super admin
      return auth.token.superAdmin == true;
    }

    function isOnboardingServiceAccount(auth) {
      // TODO: Check if auth.uid matches a known service account UID
      return false;
    }

    match /networks/{networkId} {
      // Network documents are created/updated/deleted only via backend/admin SDK.
      allow create, update, delete: if false;

      // Network-level reads: allow only to authenticated members for now.
      allow read: if request.auth != null && isNetworkMember(request.auth, networkId);

      // Compliance: Admin Responsibility Form
      match /compliance/adminResponsibilityForm {
        // Only backend service accounts can create this.
        allow create: if isOnboardingServiceAccount(request.auth);

        // Only network owners and platform super admins can read.
        allow read: if isNetworkOwner(request.auth, networkId)
                 || isSuperAdmin(request.auth);

        // Immutable once created.
        allow update, delete: if false;
      }

      // Corporate nodes
      match /corporates/{corpId} {
        allow read: if request.auth != null && isNetworkMember(request.auth, networkId);
        allow create, update, delete: if false; // backend only
      }

      // Organizations (network-scoped)
      match /orgs/{orgId} {
        allow read: if request.auth != null && isNetworkMember(request.auth, networkId);
        allow create, update, delete: if false; // backend only for now
      }

      // Venues (network-scoped)
      match /venues/{venueId} {
        allow read: if request.auth != null && isNetworkMember(request.auth, networkId);
        allow create, update, delete: if false; // backend only for now
      }

      // Links (corp-org, org-venue, etc.)
      match /links/{linkCollection}/{linkId} {
        allow read: if request.auth != null && isNetworkMember(request.auth, networkId);
        allow create, update, delete: if false; // backend only
      }

      // Network-scoped user profiles
      match /users/{uid} {
        allow read: if request.auth != null
                 && (request.auth.uid == uid || isNetworkAdmin(request.auth, networkId));
        allow create, update: if request.auth != null && request.auth.uid == uid;
        allow delete: if false;
      }

      // Network memberships
      match /memberships/{membershipId} {
        allow read: if request.auth != null && isNetworkMember(request.auth, networkId);
        allow create, update, delete: if false; // backend only
      }
    }
  }
}
