#!/usr/bin/env bash
# [P0][SECURITY][CODE] Generate File Index
# Tags: P0, SECURITY, CODE
# [MEDIUM][INFRA][INDEX]
# Tags: index, bash, zero-deps
# Fast file index generator with ZERO Node/ESLint deps.
# Requirements: git, bash, coreutils/awk/sed
# Usage:
#   scripts/index/generate-file-index.sh --write
#   scripts/index/generate-file-index.sh --check
#   scripts/index/generate-file-index.sh            # prints to stdout

set -euo pipefail

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || echo ".")"
OUT="${ROOT_DIR}/docs/INDEX.md"
MODE="print" # print|write|check

for arg in "$@"; do
  case "$arg" in
    --write) MODE="write" ;;
    --check) MODE="check" ;;
    --debug) set -x ;;
    *) echo "Unknown arg: $arg" >&2; exit 2 ;;
  esac
done

# Glob-like excludes (translated to grep -E)
EXCLUDES=(
  '^_legacy/'
  '^docs/archive/'
  '/node_modules/'
  '/\.pnpm/'
  '/dist/'
  '/coverage/'
  '/\.next/'
  '/\.vercel/'
  '/\.turbo/'
  '/\.cache/'
  '\.log$'
  '\.tmp$'
  '^docs/INDEX.md$'
)
EXCLUDE_RE="$(IFS='|'; echo "${EXCLUDES[*]}")"

# Get tracked files, excluding junk/legacy/vendor
mapfile -t FILES < <(git ls-files | grep -Ev "${EXCLUDE_RE}" | LC_ALL=C sort)

# Grouping rules
is_apps()      { [[ "$1" == apps/* ]]; }
is_packages()  { [[ "$1" == packages/* ]]; }
is_services()  { [[ "$1" == services/* ]]; }
is_docs()      { [[ "$1" == docs/* ]]; }
is_scripts()   { [[ "$1" == scripts/* || "$1" == tools/* ]]; }
is_tests()     { [[ "$1" == tests/* || "$1" =~ (^|/)__tests__/ ]]; }
is_ci_cfg()    {
  [[ "$1" == .github/* ]] && return 0
  [[ "$1" =~ (^|/)(tsconfig.*|eslint.*|vitest.*|jest.*|turbo\.json|pnpm-.*\.yaml|pnpm-workspace\.yaml|firebase.*\.json|firestore.*\.json|tailwind.*\.(cjs|ts)|postcss.*|cspell\.json|\.prettier.*|\.markdownlint\.json|\.mcp\.json|eslint\.config\.mjs|vitest\.config\.ts|jest\.config\.ts)$ ]]
}
is_root()      { [[ "$1" != */* && "$1" != .github/* ]]; }

# Buckets
declare -a APPS PKGS SVCS DOCS SCRPTS TESTS CICFG ROOT UNC

for f in "${FILES[@]}"; do
  if      is_tests     "$f"; then TESTS+=("$f")
  elif    is_ci_cfg    "$f"; then CICFG+=("$f")
  elif    is_apps      "$f"; then APPS+=("$f")
  elif    is_packages  "$f"; then PKGS+=("$f")
  elif    is_services  "$f"; then SVCS+=("$f")
  elif    is_docs      "$f"; then DOCS+=("$f")
  elif    is_scripts   "$f"; then SCRPTS+=("$f")
  elif    is_root      "$f"; then ROOT+=("$f")
  else                               UNC+=("$f")
  fi
done

short_info() {
  local file="$1"
  if git log -1 --pretty=format:%cs__%an -- "$file" >/dev/null 2>&1; then
    local meta
    meta="$(git log -1 --pretty=format:%cs__%an -- "$file")"
    local date author
    date="${meta%%__*}"
    author="${meta##*__}"
    printf " â€” _%s, %s_" "$date" "$author"
  fi
}

emit_section() {
  local title="$1"
  shift
  local -a items=("$@")
  local count="${#items[@]}"
  [[ $count -eq 0 ]] && return 0
  printf "## %s (%d)\n\n" "$title" "$count"
  for f in "${items[@]}"; do
    printf -- "- \`%s\`%s\n" "$f" "$(short_info "$f")"
  done
  printf "\n"
}

# Compute file-path-only hash (deterministic, independent of git log times)
file_hash_deterministic() {
  local -a all_files=("${APPS[@]}" "${PKGS[@]}" "${SVCS[@]}" "${DOCS[@]}" "${SCRPTS[@]}" "${TESTS[@]}" "${CICFG[@]}" "${ROOT[@]}" "${UNC[@]}")
  (IFS=$'\n'; echo "${all_files[*]}" | LC_ALL=C sort | sha256sum | awk '{print $1}')
}

render() {
  printf -- "<!-- AUTOGENERATED: do not hand-edit. Use scripts/index/generate-file-index.sh -->\n"
  printf -- "# Repository File Index\n\n"
  printf -- "This index is generated from tracked files (via \`git ls-files\`) with smart grouping and standard excludes.\n"
  printf -- "To regenerate locally:\n"
  printf -- "\`\`\`bash\nscripts/index/generate-file-index.sh --write\n\`\`\`\n\n"

  local totals=0
  totals=$(( ${#APPS[@]} + ${#PKGS[@]} + ${#SVCS[@]} + ${#DOCS[@]} + ${#SCRPTS[@]} + ${#TESTS[@]} + ${#CICFG[@]} + ${#ROOT[@]} + ${#UNC[@]} ))
  printf -- "**Total files indexed:** %d\n\n" "$totals"

  emit_section "Apps"       "${APPS[@]}"
  emit_section "Packages"   "${PKGS[@]}"
  emit_section "Services"   "${SVCS[@]}"
  emit_section "Docs"       "${DOCS[@]}"
  emit_section "Scripts"    "${SCRPTS[@]}"
  emit_section "Tests"      "${TESTS[@]}"
  emit_section "CI / Config"  "${CICFG[@]}"
  emit_section "Root"       "${ROOT[@]}"
  emit_section "Uncategorized" "${UNC[@]}"
}

# Assemble and render
BODY="$(render)"
DHASH="$(file_hash_deterministic)"

if [[ "$MODE" == "write" ]]; then
  mkdir -p "${ROOT_DIR}/docs"
  {
    printf "%s" "$BODY"
    printf -- "\n---\n\n_Index file hash:_ \`%s\`\n" "$DHASH"
  } > "$OUT"
  echo "Wrote docs/INDEX.md (${#FILES[@]} files indexed)"
  exit 0
fi

if [[ "$MODE" == "check" ]]; then
  if [[ ! -f "$OUT" ]]; then
    echo "docs/INDEX.md missing. Run --write." >&2
    exit 1
  fi
  FRESH="$(
    printf "%s" "$BODY"
    printf -- "\n---\n\n_Index file hash:_ \`%s\`\n" "$DHASH"
  )"
  if [[ "$(cat "$OUT")" != "$FRESH" ]]; then
    echo "docs/INDEX.md is stale. Re-generate with --write." >&2
    echo "Diff:" >&2
    diff -u "$OUT" <(echo "$FRESH") >&2 || true
    exit 1
  fi
  echo "File index is up to date."
  exit 0
fi

# Default: print
printf "%s" "$BODY"
printf -- "\n---\n\n_Index file hash:_ \`%s\`\n" "$DHASH"

