// [P1][INTEGRITY][SCHEMA] Schedule schemas
// Tags: P1, INTEGRITY, SCHEMA, ZOD, SCHEDULES
import { z } from "zod";

/**
 * Schedule status lifecycle
 */
export const ScheduleStatus = z.enum(["draft", "published", "active", "completed", "archived"]);
export type ScheduleStatus = z.infer<typeof ScheduleStatus>;

/**
 * Schedule visibility settings
 */
export const ScheduleVisibility = z.enum([
  "private", // Only managers can see
  "team", // All team members can see
  "public", // Public viewing (with link)
]);
export type ScheduleVisibility = z.infer<typeof ScheduleVisibility>;

/**
 * Schedule statistics
 * @property {number} [totalShifts=0] - The total number of shifts in the schedule.
 * @property {number} [assignedShifts=0] - The number of shifts that have been assigned to staff.
 * @property {number} [unassignedShifts=0] - The number of shifts that are not yet assigned.
 * @property {number} [totalHours=0] - The total number of hours for all shifts in the schedule.
 * @property {number} [totalCost=0] - The total estimated cost of the schedule.
 * @property {number} [conflictCount=0] - The number of scheduling conflicts detected.
 */
export const ScheduleStatsSchema = z.object({
  totalShifts: z.number().int().nonnegative().default(0),
  assignedShifts: z.number().int().nonnegative().default(0),
  unassignedShifts: z.number().int().nonnegative().default(0),
  totalHours: z.number().nonnegative().default(0),
  totalCost: z.number().nonnegative().default(0),
  conflictCount: z.number().int().nonnegative().default(0),
});
export type ScheduleStats = z.infer<typeof ScheduleStatsSchema>;

/**
 * Full Schedule document schema
 * Firestore path: /schedules/{orgId}/{scheduleId}
 * or /orgs/{orgId}/schedules/{scheduleId}
 * @property {string} id - The unique identifier for the schedule.
 * @property {string} orgId - The ID of the organization this schedule belongs to.
 * @property {string} name - The name of the schedule.
 * @property {string} [description] - A brief description of the schedule.
 * @property {number} startDate - The start date of the schedule as a Unix timestamp in milliseconds.
 * @property {number} endDate - The end date of the schedule as a Unix timestamp in milliseconds.
 * @property {ScheduleStatus} [status=draft] - The current status of the schedule.
 * @property {ScheduleVisibility} [visibility=team] - The visibility setting for the schedule.
 * @property {string} [templateId] - The ID of the template used to create this schedule, if any.
 * @property {string} [parentScheduleId] - The ID of the schedule this was cloned from, if any.
 * @property {ScheduleStats} [stats] - Denormalized statistics for the schedule.
 * @property {boolean} [aiGenerated=false] - Flag indicating if the schedule was generated by AI.
 * @property {string} [aiModel] - The AI model used to generate the schedule.
 * @property {number} [aiGeneratedAt] - The timestamp of when the AI generation occurred.
 * @property {number} [publishedAt] - The timestamp of when the schedule was published.
 * @property {string} [publishedBy] - The user ID of the user who published the schedule.
 * @property {string} createdBy - The user ID of the user who created the schedule.
 * @property {number} createdAt - The timestamp of when the schedule was created.
 * @property {number} updatedAt - The timestamp of when the schedule was last updated.
 */
export const ScheduleSchema = z
  .object({
    id: z.string().min(1),
    orgId: z.string().min(1, "Organization ID is required"),
    name: z.string().min(1, "Schedule name is required").max(100),
    description: z.string().max(500).optional(),

    // Time boundaries (Unix timestamps in milliseconds)
    startDate: z.number().int().positive(),
    endDate: z.number().int().positive(),

    status: ScheduleStatus.default("draft"),
    visibility: ScheduleVisibility.default("team"),

    // Metadata
    templateId: z.string().optional(), // If created from a template
    parentScheduleId: z.string().optional(), // If cloned from another schedule

    // Statistics (denormalized for performance)
    stats: ScheduleStatsSchema.optional(),

    // AI generation metadata
    aiGenerated: z.boolean().default(false),
    aiModel: z.string().optional(),
    aiGeneratedAt: z.number().int().positive().optional(),

    // Publishing
    publishedAt: z.number().int().positive().optional(),
    publishedBy: z.string().optional(),

    createdBy: z.string().min(1),
    createdAt: z.number().int().positive(),
    updatedAt: z.number().int().positive(),
  })
  .refine((data) => data.endDate > data.startDate, {
    message: "End date must be after start date",
    path: ["endDate"],
  });
export type Schedule = z.infer<typeof ScheduleSchema>;

/**
 * Schema for creating a new schedule
 * Used in POST /api/schedules
 * @property {string} orgId - The ID of the organization this schedule belongs to.
 * @property {string} name - The name of the schedule.
 * @property {string} [description] - A brief description of the schedule.
 * @property {number} startDate - The start date of the schedule as a Unix timestamp in milliseconds.
 * @property {number} endDate - The end date of the schedule as a Unix timestamp in milliseconds.
 * @property {ScheduleVisibility} [visibility=team] - The visibility setting for the schedule.
 * @property {string} [templateId] - The ID of the template to use for creating the schedule.
 */
export const CreateScheduleSchema = z
  .object({
    orgId: z.string().min(1, "Organization ID is required"),
    name: z.string().min(1, "Schedule name is required").max(100),
    description: z.string().max(500).optional(),
    startDate: z.number().int().positive(),
    endDate: z.number().int().positive(),
    visibility: ScheduleVisibility.optional().default("team"),
    templateId: z.string().optional(),
  })
  .refine((data) => data.endDate > data.startDate, {
    message: "End date must be after start date",
    path: ["endDate"],
  });
export type CreateScheduleInput = z.infer<typeof CreateScheduleSchema>;

/**
 * Schema for updating an existing schedule
 * Used in PATCH /api/schedules/{id}
 * @property {string} [name] - The new name of the schedule.
 * @property {string} [description] - The new description of the schedule.
 * @property {number} [startDate] - The new start date of the schedule as a Unix timestamp in milliseconds.
 * @property {number} [endDate] - The new end date of the schedule as a Unix timestamp in milliseconds.
 * @property {ScheduleStatus} [status] - The new status of the schedule.
 * @property {ScheduleVisibility} [visibility] - The new visibility setting for the schedule.
 */
export const UpdateScheduleSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  description: z.string().max(500).optional(),
  startDate: z.number().int().positive().optional(),
  endDate: z.number().int().positive().optional(),
  status: ScheduleStatus.optional(),
  visibility: ScheduleVisibility.optional(),
});
export type UpdateScheduleInput = z.infer<typeof UpdateScheduleSchema>;

/**
 * Schema for publishing a schedule
 * Used in POST /api/schedules/{id}/publish
 * @property {boolean} [notifyStaff=true] - Whether to notify staff members about the published schedule.
 * @property {string} [message] - An optional message to include in the notification.
 */
export const PublishScheduleSchema = z.object({
  notifyStaff: z.boolean().default(true),
  message: z.string().max(500).optional(),
});
export type PublishScheduleInput = z.infer<typeof PublishScheduleSchema>;

/**
 * Schema for cloning a schedule
 * Used in POST /api/schedules/{id}/clone
 * @property {string} name - The name for the new cloned schedule.
 * @property {number} startDate - The start date for the new schedule as a Unix timestamp in milliseconds.
 * @property {number} endDate - The end date for the new schedule as a Unix timestamp in milliseconds.
 * @property {boolean} [includeAssignments=false] - Whether to include the shift assignments in the cloned schedule.
 */
export const CloneScheduleSchema = z.object({
  name: z.string().min(1).max(100),
  startDate: z.number().int().positive(),
  endDate: z.number().int().positive(),
  includeAssignments: z.boolean().default(false),
});
export type CloneScheduleInput = z.infer<typeof CloneScheduleSchema>;

/**
 * Query parameters for listing schedules
 * @property {string} orgId - The ID of the organization to list schedules for.
 * @property {ScheduleStatus} [status] - Filter schedules by status.
 * @property {number} [startAfter] - Filter for schedules that start after this Unix timestamp (in milliseconds).
 * @property {number} [startBefore] - Filter for schedules that start before this Unix timestamp (in milliseconds).
 * @property {number} [limit=50] - The maximum number of schedules to return.
 * @property {string} [cursor] - The cursor for pagination.
 */
export const ListSchedulesQuerySchema = z.object({
  orgId: z.string().min(1, "Organization ID is required"),
  status: ScheduleStatus.optional(),
  startAfter: z.coerce.number().int().positive().optional(),
  startBefore: z.coerce.number().int().positive().optional(),
  limit: z.coerce.number().int().positive().max(100).default(50),
  cursor: z.string().optional(),
});
export type ListSchedulesQuery = z.infer<typeof ListSchedulesQuerySchema>;
